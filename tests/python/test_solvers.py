from pycontact import (
    NCPPGSSolver,
    NCPStagProjSolver,
    CCPPGSSolver,
    CCPADMMSolver,
    CCPADMMPrimalSolver,
    CCPNewtonPrimalSolver,
    RaisimSolver,
    RaisimCorrectedSolver,
    ContactProblem,
    ContactSolverSettings
)
from pycontact.solvers import PyNCPPGSSolver, PyCCPPGSSolver, PyCCPADMMSolver,PyCCPADMMSolver2, PyCCPCVXSolver, PyCCPNSNewtonPrimalSolver
from pycontact.utils.callbacks import LoggerCallback
import numpy as np
from pathlib import Path
import os

test_python_path = Path(os.path.dirname(os.path.realpath(__file__)))


def test_NCPPGSSolver():
    A = np.random.rand(3, 3)
    b = np.random.random(3)
    mus = [0.8]
    prob = ContactProblem(A, b, mus)
    solver = NCPPGSSolver()
    solver.setProblem(prob)
    x0 = np.zeros(3)
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings)
    lam = solver.getSolution()

def test_PyNCPPGSSolver():
    G = np.array([[ 0.00746183,  0.01030469, -0.02459814,  0.00146251,  0.0106132 ,
        -0.02493933],
       [ 0.01030469,  0.05200239,  0.00350998,  0.00977178,  0.05230589,
         0.00358581],
       [-0.02459814,  0.00350998,  0.11827849,  0.00287095,  0.00237138,
         0.11994601],
       [ 0.00146251,  0.00977178,  0.00287095,  0.00750077,  0.00957129,
         0.00312712],
       [ 0.0106132 ,  0.05230589,  0.00237138,  0.00957129,  0.05263244,
         0.00242249],
       [-0.02493933,  0.00358581,  0.11994601,  0.00312712,  0.00242249,
         0.12164495]])
    g = np.array([[ 0.51633112],
       [-0.03477161],
       [-2.44411637],
       [ 0.24991561],
       [-0.02367004],
       [-2.46724553]])
    prob = ContactProblem(G,g, [.9,.9])
    solver = PyNCPPGSSolver()
    solver.setProblem(prob)
    x0 = np.zeros((6,1))
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob,x0,settings,1e-3)
    lam = solver.getSolution()
    prob.computeContactComplementarity(lam, G @lam +g)

def test_NCPStagProjSolver():
    A = np.random.rand(3, 3)
    b = np.random.random(3)
    mus = [0.8]
    prob = ContactProblem(A, b, mus)
    solver = NCPStagProjSolver()
    solver.setProblem(prob)
    x0 = np.zeros(3)
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings)
    lam = solver.getSolution()


def test_CCPPGSSolver():
    A = np.random.rand(3, 3)
    b = np.random.random(3)
    mus = [0.8]
    prob = ContactProblem(A, b, mus)
    solver = CCPPGSSolver()
    solver.setProblem(prob)
    x0 = np.zeros(3)
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings)
    lam = solver.getSolution()


def test_CCPPGSSolver2():
    A = np.array(
        [
            [3.3602734, -0.19499993, -0.42120046, 2.91972569, 0.4647318, 1.00382216],
            [-0.19499993, 3.03495251, -0.89984921, 0.00883017, 2.72105923, 0.04074781],
            [-0.42120046, -0.89984921, 1.5078716, -0.42009814, -0.89749424, 0.76360414],
            [2.91972569, 0.00883017, -0.42009814, 2.9343712, -0.02104442, 1.00119508],
            [0.4647318, 2.72105923, -0.89749424, -0.02104442, 3.45194612, 0.04064117],
            [1.00382216, 0.04074781, 0.76360414, 1.00119508, 0.04064117, 1.51928342],
        ]
    )
    b = np.array(
        [
            [0.00034668],
            [0.00074063],
            [-0.00891062],
            [0.0008196],
            [0.00175098],
            [-0.32816097],
        ]
    )
    mus = [0.9, 0.9]
    prob = ContactProblem(A, b, mus)
    solver = CCPPGSSolver()
    solver.setProblem(prob)
    x0 = np.zeros(6)
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings)
    lam = solver.getSolution()
    assert prob.computeConicComplementarity(lam) < 1e-3

def test_CCPPGSSolver3():
    G = np.array([[ 0.00746183,  0.01030469, -0.02459814,  0.00146251,  0.0106132 ,
        -0.02493933],
       [ 0.01030469,  0.05200239,  0.00350998,  0.00977178,  0.05230589,
         0.00358581],
       [-0.02459814,  0.00350998,  0.11827849,  0.00287095,  0.00237138,
         0.11994601],
       [ 0.00146251,  0.00977178,  0.00287095,  0.00750077,  0.00957129,
         0.00312712],
       [ 0.0106132 ,  0.05230589,  0.00237138,  0.00957129,  0.05263244,
         0.00242249],
       [-0.02493933,  0.00358581,  0.11994601,  0.00312712,  0.00242249,
         0.12164495]])
    g = np.array([[ 0.51633112],
       [-0.03477161],
       [-2.44411637],
       [ 0.24991561],
       [-0.02367004],
       [-2.46724553]])
    prob = ContactProblem(G,g, [.9,.9])
    solver = CCPPGSSolver()
    solver.setProblem(prob)
    x0 = np.zeros((6,1))
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob,x0,settings,1e-3)
    lam = np.expand_dims(solver.getSolution(), axis = -1)
    prob.computeConicComplementarity(lam, G @lam +g)

def test_pyCCPPGSSolver2():
    G = np.array([[ 4966.01249165, -1240.28946522, -1031.95110853,  2304.47823585,
         3886.16384948,  1949.94279712,  3101.26567494,   847.17130135,
        -1031.95113888,  -649.26439802,  2922.42830527,  1949.94282247],
       [-1240.28946522,  3278.78750708, -1949.9427959 , -1229.78144134,
          910.33603352, -1031.95110621, -1764.54125972,   244.96873579,
        -1949.94277319,    67.16266426,  -898.95556738, -1031.95111298],
       [-1031.95110853, -1949.9427959 ,  3999.99999644,     7.58640634,
        -2206.16011298,   999.99999644,   386.24666091, -2172.09889442,
         1999.99997419,   866.07608026, -2029.06682359, -1000.00002581],
       [ 2304.47823585, -1229.78144134,     7.58640634,  2622.43547551,
          -10.3160952 ,  2206.16011297,   603.00131155,   105.05297493,
            7.58640054,   577.32186417,   232.87730159,  2206.16010695],
       [ 3886.16384948,   910.33603352, -2206.16011298,   -10.3160952 ,
         5622.36452322,     7.58640897,  2846.78851543,  1138.38123324,
        -2206.16013868, -1420.06658107,  3332.42285314,     7.58644628],
       [ 1949.94279712, -1031.95110621,   999.99999644,  2206.16011297,
            7.58640897,  3999.99999643,  2172.0988648 ,   386.24664759,
        -1000.00002588,  2029.06685565,   866.07608543,  1999.99997412],
       [ 3101.26567494, -1764.54125972,   386.24666091,   603.00131155,
         2846.78851543,  2172.0988648 ,  5530.45135733,   517.11456951,
          386.24623677,  1395.34700283,  3307.86814296,  2172.09671685],
       [  847.17130135,   244.96873579, -2172.09889442,   105.05297493,
         1138.38123324,   386.24664759,   517.11456951,  2714.35693425,
        -2172.0967231 ,  -797.50151956,  3037.92945963,   386.2462716 ],
       [-1031.95113888, -1949.94277319,  1999.99997419,     7.58640054,
        -2206.16013868, -1000.00002588,   386.24623677, -2172.0967231 ,
         4000.00395195,   866.07521885, -2029.06482046,  1000.00095188],
       [ -649.26439802,    67.16266426,   866.07608026,   577.32186417,
        -1420.06658107,  2029.06685565,  1395.34700283,  -797.50151956,
          866.07521885,  3084.73536801, -1083.16570071,  2029.06480651],
       [ 2922.42830527,  -898.95556738, -2029.06682359,   232.87730159,
         3332.42285314,   866.07608543,  3307.86814296,  3037.92945963,
        -2029.06482046, -1083.16570071,  5160.07292371,   866.07525138],
       [ 1949.94282247, -1031.95111298, -1000.00002581,  2206.16010695,
            7.58644628,  1999.99997412,  2172.09671685,   386.2462716 ,
         1000.00095188,  2029.06480651,   866.07525138,  4000.00395181]])
    g = np.array([[-3.45372014e-08],
       [ 1.11640710e-07],
       [-9.81012734e-03],
       [-8.30347887e-08],
       [ 8.22393506e-08],
       [-9.81012765e-03],
       [-9.59246610e-08],
       [ 6.67565704e-08],
       [-1.27337139e-07],
       [-1.08501617e-07],
       [ 4.34056213e-08],
       [-1.27665779e-07]])
    prob = ContactProblem(G,g, [.9,.9, .95,.95])
    solver = PyCCPPGSSolver()
    solver.setProblem(prob)
    solver.addCallback(LoggerCallback())
    x0 = np.zeros((12,1))
    settings = ContactSolverSettings()
    settings.max_iter_ = 100
    settings.th_stop_ = 1e-9
    settings.rel_th_stop_ = 1e-9
    solver.solve(prob, x0, settings)
    lam = solver.getSolution()
    pyprob = ContactProblem(G, g, [.9,.9, .95,.95])
    pyprob.computeConicComplementarity(lam, G @lam +g)


def test_CCPADMMSolver_solve():
    A = np.array(
        [
            [3.3602734, -0.19499993, -0.42120046, 2.91972569, 0.4647318, 1.00382216],
            [-0.19499993, 3.03495251, -0.89984921, 0.00883017, 2.72105923, 0.04074781],
            [-0.42120046, -0.89984921, 1.5078716, -0.42009814, -0.89749424, 0.76360414],
            [2.91972569, 0.00883017, -0.42009814, 2.9343712, -0.02104442, 1.00119508],
            [0.4647318, 2.72105923, -0.89749424, -0.02104442, 3.45194612, 0.04064117],
            [1.00382216, 0.04074781, 0.76360414, 1.00119508, 0.04064117, 1.51928342],
        ]
    )
    b = np.array(
        [
            [0.00034668],
            [0.00074063],
            [-0.00891062],
            [0.0008196],
            [0.00175098],
            [-0.32816097],
        ]
    )
    mus = [0.9, 0.9]
    prob = ContactProblem(A, b, mus)
    solver = CCPADMMSolver()
    solver.setProblem(prob)
    x0 = np.zeros(6)
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings)
    lam = solver.getSolution()
    assert prob.computeConicComplementarity(lam) < 1e-3

def test_CCPADMMSolver2():
    G = np.array([[ 4966.01249165, -1240.28946522, -1031.95110853,  2304.47823585,
         3886.16384948,  1949.94279712,  3101.26567494,   847.17130135,
        -1031.95113888,  -649.26439802,  2922.42830527,  1949.94282247],
       [-1240.28946522,  3278.78750708, -1949.9427959 , -1229.78144134,
          910.33603352, -1031.95110621, -1764.54125972,   244.96873579,
        -1949.94277319,    67.16266426,  -898.95556738, -1031.95111298],
       [-1031.95110853, -1949.9427959 ,  3999.99999644,     7.58640634,
        -2206.16011298,   999.99999644,   386.24666091, -2172.09889442,
         1999.99997419,   866.07608026, -2029.06682359, -1000.00002581],
       [ 2304.47823585, -1229.78144134,     7.58640634,  2622.43547551,
          -10.3160952 ,  2206.16011297,   603.00131155,   105.05297493,
            7.58640054,   577.32186417,   232.87730159,  2206.16010695],
       [ 3886.16384948,   910.33603352, -2206.16011298,   -10.3160952 ,
         5622.36452322,     7.58640897,  2846.78851543,  1138.38123324,
        -2206.16013868, -1420.06658107,  3332.42285314,     7.58644628],
       [ 1949.94279712, -1031.95110621,   999.99999644,  2206.16011297,
            7.58640897,  3999.99999643,  2172.0988648 ,   386.24664759,
        -1000.00002588,  2029.06685565,   866.07608543,  1999.99997412],
       [ 3101.26567494, -1764.54125972,   386.24666091,   603.00131155,
         2846.78851543,  2172.0988648 ,  5530.45135733,   517.11456951,
          386.24623677,  1395.34700283,  3307.86814296,  2172.09671685],
       [  847.17130135,   244.96873579, -2172.09889442,   105.05297493,
         1138.38123324,   386.24664759,   517.11456951,  2714.35693425,
        -2172.0967231 ,  -797.50151956,  3037.92945963,   386.2462716 ],
       [-1031.95113888, -1949.94277319,  1999.99997419,     7.58640054,
        -2206.16013868, -1000.00002588,   386.24623677, -2172.0967231 ,
         4000.00395195,   866.07521885, -2029.06482046,  1000.00095188],
       [ -649.26439802,    67.16266426,   866.07608026,   577.32186417,
        -1420.06658107,  2029.06685565,  1395.34700283,  -797.50151956,
          866.07521885,  3084.73536801, -1083.16570071,  2029.06480651],
       [ 2922.42830527,  -898.95556738, -2029.06682359,   232.87730159,
         3332.42285314,   866.07608543,  3307.86814296,  3037.92945963,
        -2029.06482046, -1083.16570071,  5160.07292371,   866.07525138],
       [ 1949.94282247, -1031.95111298, -1000.00002581,  2206.16010695,
            7.58644628,  1999.99997412,  2172.09671685,   386.2462716 ,
         1000.00095188,  2029.06480651,   866.07525138,  4000.00395181]])
    g = np.array([[-3.45372014e-08],
       [ 1.11640710e-07],
       [-9.81012734e-03],
       [-8.30347887e-08],
       [ 8.22393506e-08],
       [-9.81012765e-03],
       [-9.59246610e-08],
       [ 6.67565704e-08],
       [-1.27337139e-07],
       [-1.08501617e-07],
       [ 4.34056213e-08],
       [-1.27665779e-07]])
    prob = ContactProblem(G,g, [.9,.9, .95,.95])
    solver = CCPADMMSolver()
    solver.setProblem(prob)
    x0 = np.zeros((12,1))
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings, 1e-6, 1., 0.)
    lam = np.expand_dims(solver.getSolution(), axis=-1)
    pyprob = ContactProblem(G, g, [.9,.9, .95,.95])
    pyprob.computeConicComplementarity(lam, G @lam +g)

def test_pyCCPADMMSolver2():
    G = np.array([[ 4966.01249165, -1240.28946522, -1031.95110853,  2304.47823585,
         3886.16384948,  1949.94279712,  3101.26567494,   847.17130135,
        -1031.95113888,  -649.26439802,  2922.42830527,  1949.94282247],
       [-1240.28946522,  3278.78750708, -1949.9427959 , -1229.78144134,
          910.33603352, -1031.95110621, -1764.54125972,   244.96873579,
        -1949.94277319,    67.16266426,  -898.95556738, -1031.95111298],
       [-1031.95110853, -1949.9427959 ,  3999.99999644,     7.58640634,
        -2206.16011298,   999.99999644,   386.24666091, -2172.09889442,
         1999.99997419,   866.07608026, -2029.06682359, -1000.00002581],
       [ 2304.47823585, -1229.78144134,     7.58640634,  2622.43547551,
          -10.3160952 ,  2206.16011297,   603.00131155,   105.05297493,
            7.58640054,   577.32186417,   232.87730159,  2206.16010695],
       [ 3886.16384948,   910.33603352, -2206.16011298,   -10.3160952 ,
         5622.36452322,     7.58640897,  2846.78851543,  1138.38123324,
        -2206.16013868, -1420.06658107,  3332.42285314,     7.58644628],
       [ 1949.94279712, -1031.95110621,   999.99999644,  2206.16011297,
            7.58640897,  3999.99999643,  2172.0988648 ,   386.24664759,
        -1000.00002588,  2029.06685565,   866.07608543,  1999.99997412],
       [ 3101.26567494, -1764.54125972,   386.24666091,   603.00131155,
         2846.78851543,  2172.0988648 ,  5530.45135733,   517.11456951,
          386.24623677,  1395.34700283,  3307.86814296,  2172.09671685],
       [  847.17130135,   244.96873579, -2172.09889442,   105.05297493,
         1138.38123324,   386.24664759,   517.11456951,  2714.35693425,
        -2172.0967231 ,  -797.50151956,  3037.92945963,   386.2462716 ],
       [-1031.95113888, -1949.94277319,  1999.99997419,     7.58640054,
        -2206.16013868, -1000.00002588,   386.24623677, -2172.0967231 ,
         4000.00395195,   866.07521885, -2029.06482046,  1000.00095188],
       [ -649.26439802,    67.16266426,   866.07608026,   577.32186417,
        -1420.06658107,  2029.06685565,  1395.34700283,  -797.50151956,
          866.07521885,  3084.73536801, -1083.16570071,  2029.06480651],
       [ 2922.42830527,  -898.95556738, -2029.06682359,   232.87730159,
         3332.42285314,   866.07608543,  3307.86814296,  3037.92945963,
        -2029.06482046, -1083.16570071,  5160.07292371,   866.07525138],
       [ 1949.94282247, -1031.95111298, -1000.00002581,  2206.16010695,
            7.58644628,  1999.99997412,  2172.09671685,   386.2462716 ,
         1000.00095188,  2029.06480651,   866.07525138,  4000.00395181]])
    g = np.array([[-3.45372014e-08],
       [ 1.11640710e-07],
       [-9.81012734e-03],
       [-8.30347887e-08],
       [ 8.22393506e-08],
       [-9.81012765e-03],
       [-9.59246610e-08],
       [ 6.67565704e-08],
       [-1.27337139e-07],
       [-1.08501617e-07],
       [ 4.34056213e-08],
       [-1.27665779e-07]])
    prob = ContactProblem(G,g, [.9,.9, .95,.95])
    solver = PyCCPADMMSolver()
    solver.setProblem(prob)
    solver.addCallback(LoggerCallback())
    x0 = np.zeros((12,1))
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings, rho = 1e-8, over_relax = 1., eps_reg = 0.)
    lam = solver.getSolution()
    pyprob = ContactProblem(G, g, [.9,.9, .95,.95])
    pyprob.computeConicComplementarity(lam, G @lam +g)

def test_pyCCPADMMSolver22():
    G = np.array([[ 4966.01249165, -1240.28946522, -1031.95110853,  2304.47823585,
         3886.16384948,  1949.94279712,  3101.26567494,   847.17130135,
        -1031.95113888,  -649.26439802,  2922.42830527,  1949.94282247],
       [-1240.28946522,  3278.78750708, -1949.9427959 , -1229.78144134,
          910.33603352, -1031.95110621, -1764.54125972,   244.96873579,
        -1949.94277319,    67.16266426,  -898.95556738, -1031.95111298],
       [-1031.95110853, -1949.9427959 ,  3999.99999644,     7.58640634,
        -2206.16011298,   999.99999644,   386.24666091, -2172.09889442,
         1999.99997419,   866.07608026, -2029.06682359, -1000.00002581],
       [ 2304.47823585, -1229.78144134,     7.58640634,  2622.43547551,
          -10.3160952 ,  2206.16011297,   603.00131155,   105.05297493,
            7.58640054,   577.32186417,   232.87730159,  2206.16010695],
       [ 3886.16384948,   910.33603352, -2206.16011298,   -10.3160952 ,
         5622.36452322,     7.58640897,  2846.78851543,  1138.38123324,
        -2206.16013868, -1420.06658107,  3332.42285314,     7.58644628],
       [ 1949.94279712, -1031.95110621,   999.99999644,  2206.16011297,
            7.58640897,  3999.99999643,  2172.0988648 ,   386.24664759,
        -1000.00002588,  2029.06685565,   866.07608543,  1999.99997412],
       [ 3101.26567494, -1764.54125972,   386.24666091,   603.00131155,
         2846.78851543,  2172.0988648 ,  5530.45135733,   517.11456951,
          386.24623677,  1395.34700283,  3307.86814296,  2172.09671685],
       [  847.17130135,   244.96873579, -2172.09889442,   105.05297493,
         1138.38123324,   386.24664759,   517.11456951,  2714.35693425,
        -2172.0967231 ,  -797.50151956,  3037.92945963,   386.2462716 ],
       [-1031.95113888, -1949.94277319,  1999.99997419,     7.58640054,
        -2206.16013868, -1000.00002588,   386.24623677, -2172.0967231 ,
         4000.00395195,   866.07521885, -2029.06482046,  1000.00095188],
       [ -649.26439802,    67.16266426,   866.07608026,   577.32186417,
        -1420.06658107,  2029.06685565,  1395.34700283,  -797.50151956,
          866.07521885,  3084.73536801, -1083.16570071,  2029.06480651],
       [ 2922.42830527,  -898.95556738, -2029.06682359,   232.87730159,
         3332.42285314,   866.07608543,  3307.86814296,  3037.92945963,
        -2029.06482046, -1083.16570071,  5160.07292371,   866.07525138],
       [ 1949.94282247, -1031.95111298, -1000.00002581,  2206.16010695,
            7.58644628,  1999.99997412,  2172.09671685,   386.2462716 ,
         1000.00095188,  2029.06480651,   866.07525138,  4000.00395181]])
    g = np.array([[-3.45372014e-08],
       [ 1.11640710e-07],
       [-9.81012734e-03],
       [-8.30347887e-08],
       [ 8.22393506e-08],
       [-9.81012765e-03],
       [-9.59246610e-08],
       [ 6.67565704e-08],
       [-1.27337139e-07],
       [-1.08501617e-07],
       [ 4.34056213e-08],
       [-1.27665779e-07]])
    unconstrained_prob = ContactProblem(G,g, [1000.,1000.,1000.,1000.])
    solver = PyCCPADMMSolver2()
    solver.setProblem(unconstrained_prob)
    solver.addCallback(LoggerCallback())
    x0 = np.zeros((12,1))
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(unconstrained_prob, x0, settings, rho = 1e-9, over_relax = 1., eps_reg = 0.)
    lam = solver.getSolution()
    pyprob = ContactProblem(G, g, [1000.,1000.,1000.,1000.])
    pyprob.computeConicComplementarity(lam, G @lam +g)
    prob = ContactProblem(G,g, [.5,.5, .55,.55])
    solver.setProblem(prob)
    solver.addCallback(LoggerCallback())
    x0 = np.zeros((12,1))
    solver.solve(prob, x0, settings, rho = 1e-9, over_relax = 1., eps_reg = 0.)
    lam = solver.getSolution()
    pyprob = ContactProblem(G, g, [.5,.5, .55,.55])
    pyprob.computeConicComplementarity(lam, G @lam +g)
    prob = ContactProblem(G,g, [.9,.9, .95,.95])
    solver.setProblem(prob)
    solver.addCallback(LoggerCallback())
    x0 = np.zeros((12,1))
    solver.solve(prob, x0, settings, rho = 1e-9, over_relax = 1., eps_reg = 0.)
    lam = solver.getSolution()
    pyprob = ContactProblem(G, g, [.9,.9, .95,.95])
    pyprob.computeConicComplementarity(lam, G @lam +g)


def test_pyCCPCVXSolver():
    G = np.array([[ 4966.01249165, -1240.28946522, -1031.95110853,  2304.47823585,
         3886.16384948,  1949.94279712,  3101.26567494,   847.17130135,
        -1031.95113888,  -649.26439802,  2922.42830527,  1949.94282247],
       [-1240.28946522,  3278.78750708, -1949.9427959 , -1229.78144134,
          910.33603352, -1031.95110621, -1764.54125972,   244.96873579,
        -1949.94277319,    67.16266426,  -898.95556738, -1031.95111298],
       [-1031.95110853, -1949.9427959 ,  3999.99999644,     7.58640634,
        -2206.16011298,   999.99999644,   386.24666091, -2172.09889442,
         1999.99997419,   866.07608026, -2029.06682359, -1000.00002581],
       [ 2304.47823585, -1229.78144134,     7.58640634,  2622.43547551,
          -10.3160952 ,  2206.16011297,   603.00131155,   105.05297493,
            7.58640054,   577.32186417,   232.87730159,  2206.16010695],
       [ 3886.16384948,   910.33603352, -2206.16011298,   -10.3160952 ,
         5622.36452322,     7.58640897,  2846.78851543,  1138.38123324,
        -2206.16013868, -1420.06658107,  3332.42285314,     7.58644628],
       [ 1949.94279712, -1031.95110621,   999.99999644,  2206.16011297,
            7.58640897,  3999.99999643,  2172.0988648 ,   386.24664759,
        -1000.00002588,  2029.06685565,   866.07608543,  1999.99997412],
       [ 3101.26567494, -1764.54125972,   386.24666091,   603.00131155,
         2846.78851543,  2172.0988648 ,  5530.45135733,   517.11456951,
          386.24623677,  1395.34700283,  3307.86814296,  2172.09671685],
       [  847.17130135,   244.96873579, -2172.09889442,   105.05297493,
         1138.38123324,   386.24664759,   517.11456951,  2714.35693425,
        -2172.0967231 ,  -797.50151956,  3037.92945963,   386.2462716 ],
       [-1031.95113888, -1949.94277319,  1999.99997419,     7.58640054,
        -2206.16013868, -1000.00002588,   386.24623677, -2172.0967231 ,
         4000.00395195,   866.07521885, -2029.06482046,  1000.00095188],
       [ -649.26439802,    67.16266426,   866.07608026,   577.32186417,
        -1420.06658107,  2029.06685565,  1395.34700283,  -797.50151956,
          866.07521885,  3084.73536801, -1083.16570071,  2029.06480651],
       [ 2922.42830527,  -898.95556738, -2029.06682359,   232.87730159,
         3332.42285314,   866.07608543,  3307.86814296,  3037.92945963,
        -2029.06482046, -1083.16570071,  5160.07292371,   866.07525138],
       [ 1949.94282247, -1031.95111298, -1000.00002581,  2206.16010695,
            7.58644628,  1999.99997412,  2172.09671685,   386.2462716 ,
         1000.00095188,  2029.06480651,   866.07525138,  4000.00395181]])
    g = np.array([[-3.45372014e-08],
       [ 1.11640710e-07],
       [-9.81012734e-03],
       [-8.30347887e-08],
       [ 8.22393506e-08],
       [-9.81012765e-03],
       [-9.59246610e-08],
       [ 6.67565704e-08],
       [-1.27337139e-07],
       [-1.08501617e-07],
       [ 4.34056213e-08],
       [-1.27665779e-07]])
    unconstrained_prob = ContactProblem(G,g, [1000.,1000.,1000.,1000.])
    solver = PyCCPCVXSolver()
    solver.setProblem(unconstrained_prob)
    solver.addCallback(LoggerCallback())
    x0 = np.zeros((12,1))
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(unconstrained_prob, x0, settings, rho = 1e-9, over_relax = 1., eps_reg = 0.)
    lam = solver.getSolution()
    pyprob = ContactProblem(G, g, [1000.,1000.,1000.,1000.])
    pyprob.computeConicComplementarity(lam, G @lam +g)
    prob = ContactProblem(G,g, [.9,.9, .95,.95])
    solver.setProblem(prob)
    solver.addCallback(LoggerCallback())
    x0 = np.zeros((12,1))
    solver.solve(prob, x0, settings, rho = 1e-9, over_relax = 1., eps_reg = 0.)
    lam = np.expand_dims(solver.getSolution(),-1)
    pyprob = ContactProblem(G, g, [.9,.9, .95,.95])
    pyprob.computeConicComplementarity(lam, G @lam +g)

def test_CCPADMMSolver3():
    G = np.array([[ 0.00746183,  0.01030469, -0.02459814,  0.00146251,  0.0106132 ,
        -0.02493933],
       [ 0.01030469,  0.05200239,  0.00350998,  0.00977178,  0.05230589,
         0.00358581],
       [-0.02459814,  0.00350998,  0.11827849,  0.00287095,  0.00237138,
         0.11994601],
       [ 0.00146251,  0.00977178,  0.00287095,  0.00750077,  0.00957129,
         0.00312712],
       [ 0.0106132 ,  0.05230589,  0.00237138,  0.00957129,  0.05263244,
         0.00242249],
       [-0.02493933,  0.00358581,  0.11994601,  0.00312712,  0.00242249,
         0.12164495]])
    g = np.array([[ 0.51633112],
       [-0.03477161],
       [-2.44411637],
       [ 0.24991561],
       [-0.02367004],
       [-2.46724553]])
    prob = ContactProblem(G,g, [.9,.9])
    solver = CCPADMMSolver()
    solver.setProblem(prob)
    x0 = np.zeros((6,1))
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings, 0.)
    lam = np.expand_dims(solver.getSolution(), axis=-1)
    pyprob = ContactProblem(G, g, [.9,.9])
    pyprob.computeConicComplementarity(lam, G @lam +g)

# TODO : test cvxpy solver

def test_CCPCVXSolver_solve():
  G = np.zeros((3,3))
  G[0,0] = 3.5
  G[1,1] = 3.5
  G[2,2] = 1.
  g = np.zeros((3,1))
  g[2,0] = -9.81*1e-3
  mus = [0.9]
  prob = ContactProblem(G,g,mus)
  solver = PyCCPCVXSolver()
  solver.setProblem(prob)
  x0 = np.zeros((3,1))
  settings = ContactSolverSettings()
  settings.max_iter_ = 1000
  settings.th_stop_ = 1e-6
  settings.rel_th_stop_ = 1e-6
  hasConverged = solver.solve(prob, x0, settings, 0.)
  lam = np.expand_dims(solver.getSolution(), -1)
  # assert np.allclose(lam, -g)
  # assert prob.isInside(lam,1e-3)
  # assert prob.isInsideDual(G@lam+g,1e-3)
  # assert np.abs(lam.T@(G@lam+g))<1e-3

def test_CCPCVXSolver_solve2():
  npzfile = np.load(test_python_path/"data/2cubes_t0.npz")
  G = npzfile["G"]
  g = npzfile["g"]
  mus = npzfile["mus"].tolist()
  nc = g.shape[0]
  prob = ContactProblem(G,g,mus)
  solver = PyCCPCVXSolver()
  solver.setProblem(prob)
  x0 = np.zeros((nc,1))
  settings = ContactSolverSettings()
  settings.max_iter_ = 1000
  settings.th_stop_ = 1e-6
  settings.rel_th_stop_ = 1e-6
  hasConverged = solver.solve(prob, x0, settings, 0.)
  lam = np.expand_dims(solver.getSolution(), -1)
  # assert prob.isInside(lam,1e-3)
  # assert prob.isInsideDual(G@lam+g,1e-3)
  # assert np.abs(lam.T@(G@lam+g))<1e-3

def create_sliding_cube_problem():
    G = np.array([[ 4.1224,  1.5   ,  1.56  ,  1.1224,  1.5   ,  1.56  ,  4.1224,
        -1.5   , -1.56  ,  1.1224, -1.5   , -1.56  ],
       [ 1.5   ,  4.1224, -1.56  , -1.5   ,  4.1224,  1.56  ,  1.5   ,
         1.1224, -1.56  , -1.5   ,  1.1224,  1.56  ],
       [ 1.56  , -1.56  ,  4.    ,  1.56  , -1.56  ,  1.    ,  1.56  ,
        -1.56  ,  1.    ,  1.56  , -1.56  , -2.    ],
       [ 1.1224, -1.5   ,  1.56  ,  4.1224, -1.5   ,  1.56  ,  1.1224,
         1.5   , -1.56  ,  4.1224,  1.5   , -1.56  ],
       [ 1.5   ,  4.1224, -1.56  , -1.5   ,  4.1224,  1.56  ,  1.5   ,
         1.1224, -1.56  , -1.5   ,  1.1224,  1.56  ],
       [ 1.56  ,  1.56  ,  1.    ,  1.56  ,  1.56  ,  4.    ,  1.56  ,
         1.56  , -2.    ,  1.56  ,  1.56  ,  1.    ],
       [ 4.1224,  1.5   ,  1.56  ,  1.1224,  1.5   ,  1.56  ,  4.1224,
        -1.5   , -1.56  ,  1.1224, -1.5   , -1.56  ],
       [-1.5   ,  1.1224, -1.56  ,  1.5   ,  1.1224,  1.56  , -1.5   ,
         4.1224, -1.56  ,  1.5   ,  4.1224,  1.56  ],
       [-1.56  , -1.56  ,  1.    , -1.56  , -1.56  , -2.    , -1.56  ,
        -1.56  ,  4.    , -1.56  , -1.56  ,  1.    ],
       [ 1.1224, -1.5   ,  1.56  ,  4.1224, -1.5   ,  1.56  ,  1.1224,
         1.5   , -1.56  ,  4.1224,  1.5   , -1.56  ],
       [-1.5   ,  1.1224, -1.56  ,  1.5   ,  1.1224,  1.56  , -1.5   ,
         4.1224, -1.56  ,  1.5   ,  4.1224,  1.56  ],
       [-1.56  ,  1.56  , -2.    , -1.56  ,  1.56  ,  1.    , -1.56  ,
         1.56  ,  1.    , -1.56  ,  1.56  ,  4.    ]])
    g = np.array([[ 0.     ],
       [ 1.     ],
       [-0.00981],
       [ 0.     ],
       [ 1.     ],
       [-0.00981],
       [ 0.     ],
       [ 1.     ],
       [-0.00981],
       [ 0.     ],
       [ 1.     ],
       [-0.00981]])
    M = np.array([[1.        , 0.        , 0.        , 0.        , 0.        ,
        0.        ],
       [0.        , 1.        , 0.        , 0.        , 0.        ,
        0.        ],
       [0.        , 0.        , 1.        , 0.        , 0.        ,
        0.        ],
       [0.        , 0.        , 0.        , 0.00666667, 0.        ,
        0.        ],
       [0.        , 0.        , 0.        , 0.        , 0.00666667,
        0.        ],
       [0.        , 0.        , 0.        , 0.        , 0.        ,
        0.00666667]])
    J = np.array([[ 1.   ,  0.   ,  0.   ,  0.   , -0.104,  0.1  ],
       [ 0.   ,  1.   ,  0.   ,  0.104,  0.   ,  0.1  ],
       [ 0.   ,  0.   ,  1.   , -0.1  , -0.1  ,  0.   ],
       [ 1.   ,  0.   ,  0.   ,  0.   , -0.104, -0.1  ],
       [ 0.   ,  1.   ,  0.   ,  0.104,  0.   ,  0.1  ],
       [ 0.   ,  0.   ,  1.   ,  0.1  , -0.1  ,  0.   ],
       [ 1.   ,  0.   ,  0.   ,  0.   , -0.104,  0.1  ],
       [ 0.   ,  1.   ,  0.   ,  0.104,  0.   , -0.1  ],
       [ 0.   ,  0.   ,  1.   , -0.1  ,  0.1  ,  0.   ],
       [ 1.   ,  0.   ,  0.   ,  0.   , -0.104, -0.1  ],
       [ 0.   ,  1.   ,  0.   ,  0.104,  0.   , -0.1  ],
       [ 0.   ,  0.   ,  1.   ,  0.1  ,  0.1  ,  0.   ]])
    dqf = np.array([ 0.     ,  1.     , -0.00981,  0.     ,  0.     ,  0.     ])
    vstar = np.array([[-0.00000000e+00],
       [-0.00000000e+00],
       [ 3.46944695e-19],
       [-0.00000000e+00],
       [-0.00000000e+00],
       [ 3.46944695e-19],
       [-0.00000000e+00],
       [-0.00000000e+00],
       [ 3.46944695e-19],
       [-0.00000000e+00],
       [-0.00000000e+00],
       [ 3.46944695e-19]])
    mus = [0.95, 0.95, 0.95, 0.95]
    return G, g, M, J, dqf, vstar, mus

def test_CCPNSPrimalSolver_proj():
    G, g, M, J, dqf, vstar, mus = create_sliding_cube_problem()
    prob = ContactProblem(G,g,M,J,dqf,vstar,mus)
    prob.Del_.computeChol(1e-9)
    prob.Del_.evaluateDel()
    solver = PyCCPNSNewtonPrimalSolver()
    solver.setProblem(prob)

    nc = len(mus)
    x0 = np.zeros_like(g)
    maxiter = 200
    eps = 1e-9
    eps_reg = 1e-6
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver2 = CCPADMMPrimalSolver()
    solver2.setProblem(prob)
    solver2.solve(prob,x0, settings)
    dq2 = solver2.getSolution()
    lam2 = solver2.getDualSolution()

    R = eps_reg * G.diagonal()
    # y =  - (J @ dq2 - vstar[:,0]) /R
    y = solver.compliance_mapping(prob, R, J@dq2)
    mus_tilde = [prob.contact_constraints_[j].mu_ * np.sqrt(R[3*j]/R[3*j+2]) for j in range(nc)]
    prob_tilde = ContactProblem(prob.Del_.G_, prob.g_, mus_tilde)
    lam = solver.projK_R(prob_tilde, R, y )
    v = prob.vstar_ - R * lam
    assert prob.isInsideDual(J @ dq2 - v, 1e-5)



def test_pyCCPNSPrimalSolver_solve():
    G, g, M, J, dqf, vstar, mus = create_sliding_cube_problem()
    prob = ContactProblem(G,g,M,J,dqf,vstar,mus)
    solver = PyCCPNSNewtonPrimalSolver()
    R = solver.computeR(prob)
    solver.setProblem(prob)
    x0 = np.zeros_like(g)
    maxiter = 200
    eps = 1e-9
    settings = ContactSolverSettings()
    settings.max_iter_ = maxiter
    settings.th_stop_ = eps
    settings.rel_th_stop_ = eps
    solver.solve(prob,x0, settings, debug = True)
    dq = solver.getSolution()
    lam = solver.dqtolam_mapping(prob, R, dq)[:,None]
    solver2 = CCPADMMPrimalSolver()
    solver2.setProblem(prob)
    R2 = 1e-6 * G.diagonal()
    solver2.solve(prob,x0, settings)
    dq2 = solver2.getSolution()
    lam2 = solver2.getDualSolution()[:,None]
    assert np.abs(lam2.T @ ((G + np.diag(R2)) @lam2 + g ))<1e-5
    assert np.abs(lam.T @ ((G + np.diag(R)) @lam + g ))<1e-5
    dq0 = prob.dqf_ + np.linalg.inv(M) @ prob.J_.T @ lam2[:,0]
    solver.solve(prob,lam2, settings)
    dq = solver.getSolution()
    lam = solver.dqtolam_mapping(prob, R, dq)[:,None]
    assert np.abs(lam.T @ ((G + np.diag(R)) @lam + g ))<1e-5

def test_pyCCPNewtonPrimalSolver_solve2():
    G = np.array([[ 5.4754948 , -0.44979429, -0.86020481],
       [-0.44979429,  4.7250972 , -1.83773453],
       [-0.86020481, -1.83773453,  2.17147606]])
    g = np.array([[ 0.00018599],
       [ 0.00039757],
       [-0.00902651]])
    M = np.array([[ 1.00000000e+00, -5.55111512e-17,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [-5.55111512e-17,  1.00000000e+00, -2.77555756e-17,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00, -2.77555756e-17,  1.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         6.66666667e-03, -4.33680869e-19,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
        -4.33680869e-19,  6.66666667e-03, -2.16840434e-19],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00, -2.16840434e-19,  6.66666667e-03]])
    J = np.array([[ 0.55336033,  0.82676652,  0.10123962,  0.07549218, -0.06765351,
         0.13985909],
       [-0.71585697,  0.53418933, -0.44965605,  0.10065678,  0.11994622,
        -0.01775105],
       [-0.42584169,  0.17634873,  0.88744576, -0.0711097 , -0.04616041,
        -0.0249493 ]])
    dqf = np.array([-0.0537134 ,  0.24911889, -0.30781979, -1.79663027, -1.16627067,
       -0.63035959])
    vstar = np.array([[-0.00000000e+00],
       [-0.00000000e+00],
       [ 2.12512089e-05]])
    mus = [0.95]
    nc = len(mus)
    R = np.zeros(3*nc)
    for j in range(nc):
        R[3*j+2] = np.max([np.linalg.norm(G[3*j:3*j+3,3*j:3*j+3])/(4*np.pi*np.pi) , 0.])
        R[3*j] = 1e-3 * R[3*j+2]
        R[3*j+1] = R[3*j]
    prob = ContactProblem(G,g,M,J,dqf,vstar,mus)
    solver = PyCCPNSNewtonPrimalSolver()
    solver.setProblem(prob)
    solver2 = CCPNewtonPrimalSolver()
    solver2.setProblem(prob)
    x0 = np.zeros_like(g)
    maxiter = 100
    eps = 1e-6
    # solver.solve(prob,x0, maxiter, eps)
    # dq = solver.getSolution()
    # solver2 = CCPADMMPrimalSolver()
    # solver2.setProblem(prob)
    # solver2.solve(prob,x0, maxiter, eps)
    # dq2 = solver2.getSolution()
    # lam2 = solver2.getDualSolution()[:,None]
    # assert np.allclose(dq, dq2)
    lam0 = np.array([[0.145076  ],
       [0.30993922],
       [0.76482271]])
    # dq0 = prob.dqf_ + np.linalg.inv(M) @ prob.J_.T @ lam2[:,0]
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver2.solve(prob,lam0, settings)
    dq2 = solver2.getSolution()
    solver.solve(prob,lam0, settings)
    dq = solver.getSolution()
    assert np.allclose(dq, dq2)
    lam = solver.compliance_mapping(prob, R, J@dq)
    lam2 = solver2.getDualSolution()
    assert np.allclose(lam, lam2,1e-1)

def test_pyCCPNewtonPrimalSolver_solve3():
  # ball in allegro hand
  G = np.array([[ 3.54487830e-01, -1.56125113e-17,  2.61292724e-17,
        -9.70611328e-02, -1.85088901e-01, -8.90919316e-02,
         1.14699643e-01, -7.02513097e-03, -1.06622888e-02],
       [-6.93889390e-18,  3.54487830e-01, -2.25514052e-17,
         4.10505520e-02,  5.45144842e-02,  2.87804517e-02,
        -3.49983171e-02,  2.55919028e-01,  9.93151662e-02],
       [ 2.98155597e-17, -3.55618313e-17,  1.00000000e-01,
        -4.47572434e-02, -8.22342741e-02, -3.51327955e-02,
         1.81067978e-02, -9.82310059e-02,  4.77633348e-03],
       [-9.70611328e-02,  4.10505520e-02, -4.47572434e-02,
         3.54983658e-01,  6.24500451e-17, -1.24900090e-16,
         2.44785519e-01,  7.15439467e-02,  7.11600891e-02],
       [-1.85088901e-01,  5.45144842e-02, -8.22342741e-02,
         6.93889390e-17,  3.54983658e-01, -5.89805982e-17,
        -1.50344004e-01,  1.85587565e-01, -6.00911948e-02],
       [-8.90919316e-02,  2.87804517e-02, -3.51327955e-02,
        -1.28369537e-16, -5.89805982e-17,  1.00000000e-01,
        -9.07855696e-02,  2.08012100e-02,  3.64045330e-02],
       [ 1.14699643e-01, -3.49983171e-02,  1.81067978e-02,
         2.44785519e-01, -1.50344004e-01, -9.07855696e-02,
         3.54971923e-01,  6.93889390e-18, -1.56125113e-17],
       [-7.02513097e-03,  2.55919028e-01, -9.82310059e-02,
         7.15439467e-02,  1.85587565e-01,  2.08012100e-02,
         6.93889390e-18,  3.54971923e-01,  1.21430643e-16],
       [-1.06622888e-02,  9.93151662e-02,  4.77633348e-03,
         7.11600891e-02, -6.00911948e-02,  3.64045330e-02,
        -1.56125113e-17,  1.21430643e-16,  1.00000000e-01]])
  g = np.array([[ 0.00165058],
    [-0.00281272],
    [-0.01007722],
    [ 0.00732922],
    [ 0.02622216],
    [-0.00979829],
    [-0.00032159],
    [ 0.00971973],
    [-0.00294113]])
  mus = [.9,.9,.9]
  M = np.array([[ 1.00000000e+01,  0.00000000e+00, -4.51028104e-17,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  1.00000000e+01,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [-4.51028104e-17,  0.00000000e+00,  1.00000000e+01,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         1.00000000e-02, -2.71050543e-20,  1.11808349e-19],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
        -2.71050543e-20,  1.00000000e-02,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         1.11808349e-19,  0.00000000e+00,  1.00000000e-02]])
  J = np.array([[ 9.96397344e-01,  6.93355535e-02, -4.88355881e-02,
         2.99043575e-03, -4.94988086e-02, -9.26302045e-03],
       [-5.92790133e-02,  9.81208352e-01,  1.83619632e-01,
         5.02650444e-02,  3.49775589e-03, -2.46359850e-03],
       [ 6.06492557e-02, -1.80063188e-01,  9.81783538e-01,
        -6.93889390e-18, -3.46944695e-18, -3.14418630e-18],
       [ 3.54640809e-01,  8.79834458e-01, -3.16419379e-01,
        -6.50772313e-03,  1.92481898e-02,  4.62276250e-02],
       [ 1.28876251e-01, -3.81183170e-01, -9.15472721e-01,
         1.79079092e-02,  4.44280386e-02, -1.59778834e-02],
       [-9.26078187e-01,  2.83885043e-01, -2.48572874e-01,
         8.67361738e-19, -2.08166817e-17, -1.49077799e-17],
       [ 9.80480833e-01,  1.29814147e-01,  1.47667270e-01,
        -5.61006120e-03, -1.28175722e-02,  4.85175874e-02],
       [ 1.11101883e-01,  2.53839726e-01, -9.60844298e-01,
         4.95091292e-02,  6.55493220e-03,  7.45642108e-03],
       [-1.62215002e-01,  9.58495530e-01,  2.34462390e-01,
         2.08166817e-17,  3.46944695e-18,  1.73472348e-18]])
  vstar = np.array([[-0.00000000e+00],
       [-0.00000000e+00],
       [ 8.93573682e-05],
       [-0.00000000e+00],
       [-0.00000000e+00],
       [ 9.91813224e-05],
       [-0.00000000e+00],
       [-0.00000000e+00],
       [ 9.89489163e-05]])
  dqf = np.array([ 0.01418917,  0.0018922 , -0.01088471, -0.06665827,  0.29799905,
       -0.19428938])
  prob = ContactProblem(G,g,M,J,dqf,vstar,mus)
  solver = PyCCPNSNewtonPrimalSolver()
  solver.setProblem(prob)
  solver2 = CCPNewtonPrimalSolver()
  solver2.setProblem(prob)
  solver3 = CCPADMMSolver()
  solver3.setProblem(prob)
  R = solver.computeR(prob)
  lam0 = np.zeros((9,1))
  maxiter = 100
  eps = 1e-9
  eps_rel = 1e-12
  settings = ContactSolverSettings()
  settings.max_iter_ = 100
  settings.th_stop_ = eps
  settings.rel_th_stop_ = eps_rel
  solved2 = solver2.solve(prob, lam0, settings)
  dq2 = solver2.getSolution()
  v2 = J @ dq2
  lam2 = solver2.getDualSolution()
  solved = solver.solve(prob,lam0, settings)
  dq = solver.getSolution()
  v = J @ dq
  lam = solver.getDualSolution()
  solved3 = solver3.solve(prob,lam0, settings)
  assert solved and solved2

def test_pyCCPNewtonPrimalSolver_gradients():
    G = np.array([[ 5.4754948 , -0.44979429, -0.86020481],
       [-0.44979429,  4.7250972 , -1.83773453],
       [-0.86020481, -1.83773453,  2.17147606]])
    g = np.array([[ 0.00018599],
       [ 0.00039757],
       [-0.00902651]])
    M = np.array([[ 1.00000000e+00, -5.55111512e-17,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [-5.55111512e-17,  1.00000000e+00, -2.77555756e-17,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00, -2.77555756e-17,  1.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         6.66666667e-03, -4.33680869e-19,  0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
        -4.33680869e-19,  6.66666667e-03, -2.16840434e-19],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00, -2.16840434e-19,  6.66666667e-03]])
    J = np.array([[ 0.55336033,  0.82676652,  0.10123962,  0.07549218, -0.06765351,
         0.13985909],
       [-0.71585697,  0.53418933, -0.44965605,  0.10065678,  0.11994622,
        -0.01775105],
       [-0.42584169,  0.17634873,  0.88744576, -0.0711097 , -0.04616041,
        -0.0249493 ]])
    dqf = np.array([-0.0537134 ,  0.24911889, -0.30781979, -1.79663027, -1.16627067,
       -0.63035959])
    vstar = np.array([[-0.00000000e+00],
       [-0.00000000e+00],
       [ 2.12512089e-05]])
    mus = [0.95]
    nc = len(mus)
    R = np.zeros(3*nc)
    for j in range(nc):
        R[3*j+2] = np.max([np.linalg.norm(G[3*j:3*j+3,3*j:3*j+3])/(4*np.pi*np.pi) , 0.])
        R[3*j] = 1e-3 * R[3*j+2]
        R[3*j+1] = R[3*j]
    prob = ContactProblem(G,g,M,J,dqf,vstar,mus)
    solver = PyCCPNSNewtonPrimalSolver()
    solver.setProblem(prob)
    solver2 = CCPNewtonPrimalSolver()
    solver2.setProblem(prob)
    solver2.setCompliance(prob, 1e-6)
    x0 = np.zeros_like(g)
    maxiter = 200
    eps = 1e-9
    dq = np.array([ 0.06310816,  0.14402246, -0.44633481, -1.33775304, -0.86839345,
       -0.46935932])
    grad_v = solver.grad_cost_unconstrained(prob, R, dq)
    grad_v2 = np.zeros_like(grad_v)
    solver2.computeGrad(prob, R, dq, grad_v2)
    def grad_fd(f, v):
        delta = 1e-6
        grad_v_fd = np.zeros_like(v)
        for i in range(len(v)):
            dv = np.zeros_like(v)
            dv[i] = delta
            grad_v_fd[i] =(f(v+dv)- f(v- dv))/(2*delta)
        return grad_v_fd
    def hess_fd(f,v):
        delta = 1e-6
        hess_v_fd = np.zeros((len(v), len(v)))
        for i in range(len(v)):
            dv = np.zeros_like(v)
            dv[i] = delta
            hess_v_fd[i] = (grad_fd(f, v+dv)- grad_fd(f, v-dv))/(2*delta)
        return hess_v_fd
    grad_v_fd = grad_fd(lambda x : solver.cost_regularization(prob,R,x), dq)
    grad_v = solver.gradv_cost_regularization(prob, R, dq)
    solver2.computeRegularizationGrad(prob, R, dq, grad_v2)
    assert np.allclose(grad_v_fd, grad_v, atol=1e-2)
    y = np.zeros(3*nc)
    y[2] = -1.
    grad_y_fd = grad_fd(lambda x : solver.cost_regularization(prob, R, 0., x), y)
    grad_y = solver.grady_cost_regularization(prob, R, y)
    assert np.allclose(grad_y_fd, grad_y)
    y[2] = 1.
    grad_y_fd = grad_fd(lambda x : solver.cost_regularization(prob, R, 0., x), y)
    grad_y = solver.grady_cost_regularization(prob, R, y)
    assert np.allclose(grad_y_fd, grad_y)
    y = solver.dqtoy_mapping(prob, R, dq)
    grad_y_fd = grad_fd(lambda x : solver.cost_regularization(prob, R, 0., x), y)
    grad_y = solver.grady_cost_regularization(prob, R, y)
    assert np.allclose(grad_y_fd, grad_y)
    y = np.zeros(3*nc)
    y[2] = -1.
    y_tilde = np.sqrt(R) *  y
    hess_y_fd = hess_fd(lambda x: solver.cost_regularization(prob, R, 0., x), y)
    hess_y = solver.hessy_cost_regularization(prob, R, y)
    hess_y2 = np.zeros_like(hess_y)
    solver2.computeHessReg(prob, R, y, y_tilde,  hess_y2)
    assert np.allclose(hess_y, hess_y_fd, atol = 1e-2)
    y[2] = 1.
    y_tilde = np.sqrt(R) *  y
    hess_y_fd = hess_fd(lambda x: solver.cost_regularization(prob, R, 0., x), y)
    hess_y = solver.hessy_cost_regularization(prob, R, y)
    hess_y2 = np.zeros_like(hess_y)
    solver2.computeHessReg(prob, R, y, y_tilde,  hess_y2)
    assert np.allclose(hess_y, hess_y_fd, atol = 1e-2)
    y = solver.dqtoy_mapping(prob, R, dq)
    y_tilde = np.sqrt(R) *  y
    hess_y_fd = hess_fd(lambda x: solver.cost_regularization(prob, R, 0., x), y)
    hess_y = solver.hessy_cost_regularization(prob, R, y)
    hess_y2 = np.zeros_like(hess_y)
    solver2.computeHessReg(prob, R, y, y_tilde,  hess_y2)
    assert np.allclose(hess_y, hess_y_fd, atol = 1e-2)
    dq = np.array([-0.52099964,  0.66950461,  0.24624027, -3.63213918, -2.35777956,
       -1.27436066])
    y = solver.dqtoy_mapping(prob, R, dq)
    y_tilde = np.sqrt(R) *  y
    hess_y_fd = hess_fd(lambda x: solver.cost_regularization(prob, R, 0., x), y)
    hess_y = solver.hessy_cost_regularization(prob, R, y)
    hess_y2 = np.zeros_like(hess_y)
    solver2.computeHessReg(prob, R, y, y_tilde,  hess_y2)
    assert np.allclose(hess_y, hess_y_fd, atol = 1e-2)
    hess_v =  solver.hess_cost_unconstrained(prob, R, dq)
    hess_v2 = np.zeros_like(hess_v)
    solver2.computeHess(prob, R, dq, hess_v2)
    assert np.allclose(hess_v, hess_v2, atol = 1e-2)


def test_pyCCPNewtonPrimalSolver_hess():
    G, g, M, J, dqf, vstar, mus = create_sliding_cube_problem()
    prob = ContactProblem(G,g,M,J,dqf,vstar,mus)
    solver = PyCCPNSNewtonPrimalSolver()
    solver.setProblem(prob)
    solver2 = CCPNewtonPrimalSolver()
    solver2.setProblem(prob)
    lam0 = np.zeros_like(g)
    dq0 = np.array([ 0.     ,  1.     , -0.00981,  0.     ,  0.     ,  0.     ])
    R = np.zeros(3*prob.nc_)
    for j in range(prob.nc_):
        R[3*j+2] = np.max([np.linalg.norm(G[3*j:3*j+3,3*j:3*j+3])/(4*np.pi*np.pi) , 0.])
        R[3*j] = 1e-3 * R[3*j+2]
        R[3*j+1] = R[3*j]
    def grad_fd(f, v):
        delta = 1e-8
        grad_v_fd = np.zeros_like(v)
        for i in range(len(v)):
            dv = np.zeros_like(v)
            dv[i] = delta
            grad_v_fd[i] =(f(v+dv)- f(v- dv))/(2*delta)
        return grad_v_fd
    def hess_fd(f,v):
      delta = 1e-8
      hess_v_fd = np.zeros((len(v), len(v)))
      for i in range(len(v)):
          dv = np.zeros_like(v)
          dv[i] = delta
          hess_v_fd[i] = (grad_fd(f, v+dv)- grad_fd(f, v-dv))/(2*delta)
      return hess_v_fd
    y = solver.dqtoy_mapping(prob, R, dq0)
    grad_y_fd = grad_fd(lambda x : solver.cost_regularization(prob, R, 0., x), y)
    grad_y = solver.grady_cost_regularization(prob, R, y)
    assert np.allclose(grad_y_fd, grad_y, atol = 1e-4)
    y = solver.dqtoy_mapping(prob, R, dq0)
    hess_y_fd = hess_fd(lambda x: solver.cost_regularization(prob, R, 0., x), y)
    hess_y_fd2 = np.zeros((3*prob.nc_,3*prob.nc_))
    for i in range(len(y)):
        dy = np.zeros_like(y)
        delta = 1e-6
        dy[i] = delta
        hess_y_fd2[i] = (solver.grady_cost_regularization(prob, R, y+dy) - solver.grady_cost_regularization(prob, R, y-dy))/(2*delta)
    hess_y = solver.hessy_cost_regularization(prob, R, y)
    hess_y2 = np.zeros_like(hess_y)
    # solver2.computeHessReg(prob, R, y, np.sqrt(R)*y, hess_y2)
    assert np.allclose(hess_y, hess_y_fd2, atol = 1e-2)

def test_pyCCPNewtonPrimalSolver_grad_projKR():
    G, g, M, J, dqf, vstar, mus = create_sliding_cube_problem()
    prob = ContactProblem(G,g,M,J,dqf,vstar,mus)
    solver = PyCCPNSNewtonPrimalSolver()
    solver.setProblem(prob)
    lam0 = np.zeros_like(g)
    dq0 = np.array([ 0.     ,  1.     , -0.00981,  0.     ,  0.     ,  0.     ])
    R = np.zeros(3*prob.nc_)
    for j in range(prob.nc_):
        R[3*j+2] = np.max([np.linalg.norm(G[3*j:3*j+3,3*j:3*j+3])/(4*np.pi*np.pi) , 0.])
        R[3*j] = 1e-3 * R[3*j+2]
        R[3*j+1] = R[3*j]
    y = solver.dqtoy_mapping(prob, R, dq0)
    grad_proj_fd = np.zeros((3*prob.nc_, 3*prob.nc_))
    for j in range(3*prob.nc_):
        delta = 1e-6
        for i in range(len(y)):
            dy = np.zeros_like(y)
            dy[i] = delta
            grad_proj_fd[i] =(solver.projK_R(prob, R, y+dy)- solver.projK_R(prob, R, y-dy))/(2*delta)
    assert True


def test_CCPNewtonPrimalSolver_init():
    solver = CCPNewtonPrimalSolver()
    assert True

def test_RaisimSolver_computeGinv():
    G = np.random.rand(3, 3)
    g = np.random.random(3)
    mus = [0.8]
    prob = ContactProblem(G, g, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    assert True


def test_RaisimSolver_getGinv():
    nc = np.random.randint(1, 10)
    G = np.random.rand(3 * nc, 3 * nc)
    b = np.random.random(3 * nc)
    mus = [0.8] * nc
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    for i in range(nc):
        Ginv = solver.getGinv(i)
        assert np.all(
            np.isclose(Ginv @ G[3 * i : 3 * (i + 1), 3 * i : 3 * (i + 1)], np.eye(3))
        )


def test_RaisimSolver_computeGlam():
    nc = np.random.randint(1, 10)
    G = np.random.rand(3 * nc, 3 * nc)
    b = np.random.random(3 * nc)
    lam = np.random.random(3 * nc)
    mus = [0.8] * nc
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    solver.computeGlam(G, lam)
    assert True


def test_RaisimSolver_updateGlam():
    nc = np.random.randint(1, 10)
    G = np.random.rand(3 * nc, 3 * nc)
    b = np.random.random(3 * nc)
    lam = np.random.random(3 * nc)
    mus = [0.8] * nc
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    solver.computeGlam(G, lam)
    i = np.random.randint(nc)
    lami = np.random.random(3)
    solver.updateGlam(i, G, lami)
    assert True


def test_RaisimSolver_getGlam():
    nc = np.random.randint(1, 10)
    G = np.random.rand(3 * nc, 3 * nc)
    b = np.random.random(3 * nc)
    lam = np.random.random(3 * nc)
    mus = [0.8] * nc
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    solver.computeGlam(G, lam)
    for i in range(nc):
        for j in range(nc):
            Glamij = solver.getGlam(i, j)
            # print(
            #     Alamij,
            #     A[3 * i : 3 * (i + 1), 3 * i : 3 * (i + 1)] @ lam[3 * j : 3 * (j + 1)],
            # )
            # assert np.all(
            #     np.isclose(
            #         Alamij,
            #         A[3 * i : 3 * (i + 1), 3 * i : 3 * (i + 1)]
            #         @ lam[3 * j : 3 * (j + 1)],
            #     )
            # )


def test_RaisimSolver_setGlam():
    nc = np.random.randint(1, 10)
    G = np.random.rand(3 * nc, 3 * nc)
    b = np.random.random(3 * nc)
    lam = np.random.random(3 * nc)
    mus = [0.8] * nc
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    solver.computeGlam(G, lam)
    for i in range(nc):
        for j in range(nc):
            Glamij = np.random.random(3)
            solver.setGlam(i, j, Glamij)


def test_RaisimSolver_computeC():
    nc = np.random.randint(1, 10)
    G = np.random.rand(3 * nc, 3 * nc)
    b = np.random.random(3 * nc)
    lam = np.random.random(3 * nc)
    mus = [0.8] * nc
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    solver.computeC(G, b, lam)
    assert True


def test_RaisimSolver_updateC():
    nc = np.random.randint(1, 10)
    G = np.random.rand(3 * nc, 3 * nc)
    b = np.random.random(3 * nc)
    lam = np.random.random(3 * nc)
    mus = [0.8] * nc
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    solver.computeC(G, b, lam)
    i = np.random.randint(nc)
    lami = np.random.random(3)
    solver.updateC(i, G, b, lami)
    assert True


def test_RaisimSolver_getC():
    nc = np.random.randint(1, 10)
    G = np.random.rand(3 * nc, 3 * nc)
    b = np.random.random(3 * nc)
    lam = np.random.random(3 * nc)
    mus = [0.8] * nc
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    solver.computeC(G, b, lam)
    i = np.random.randint(nc)
    lami = np.random.random(3)
    solver.updateC(i, G, b, lami)
    for i in range(nc):
        solver.getC(i)
    assert True


def test_RaisimSolver_computeLamV0():
    G = np.random.rand(3, 3)
    b = np.random.random(3)
    mus = [0.8]
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    solver.computeGinv(G)
    Ginvi = solver.getGinv(0)
    ci = solver.getC(0)
    lam = np.zeros(3)
    solver.computeLamV0(Ginvi, ci, lam)
    # assert np.allclose(np.zeros(3), G @ lam + b)
    assert True


def test_RaisimSolver_getSolution():
    G = np.random.rand(3, 3)
    b = np.random.random(3)
    mus = [0.8]
    prob = ContactProblem(G, b, mus)
    solver = RaisimSolver()
    solver.setProblem(prob)
    x0 = np.zeros(3)
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings)
    lam = solver.getSolution()

def test_RaisimSolver_getSolution2():
  npzfile = np.load(test_python_path/'data/sliding_cube.npz')
  G = npzfile["G"]
  g = npzfile["g"]
  mus = npzfile["mus"].tolist()
  lam0 = npzfile["lam0"]
  i =0
  lam0i = lam0[3*i:3*(i+1)]
  Gii = G[3*i:3*(i+1), 3*i:3*(i+1)]
  Gi = G[3*i:3*(i+1),:]
  gi = g[3*i:3*(i+1)]
  ci = Gi@lam0 + gi - Gii @ lam0i
  lam_v0i,_,_,_ = np.linalg.lstsq(Gii,-ci,rcond=None)
  nc = g.shape[0]
  prob = ContactProblem(G,g,mus)
  solver = RaisimSolver()
  solver.setProblem(prob)
  settings = ContactSolverSettings()
  settings.max_iter_ = 1000
  settings.th_stop_ = 1e-6
  settings.rel_th_stop_ = 1e-6
  hasConverged = solver.solve(prob, lam0, settings)
  lam = np.expand_dims(solver.getSolution(), -1)
  assert hasConverged
  lam0b = np.zeros((nc,1))
  lam0bi = lam0b[3*i:3*(i+1)]
  cib = Gi@lam0b + gi - Gii @ lam0bi
  lam_v0ib,_,_,_ = np.linalg.lstsq(Gii,-cib, rcond = None)
  hasConverged = solver.solve(prob, lam0b, settings)
  lamb = np.expand_dims(solver.getSolution(), -1)
  assert hasConverged

def test_RaisimCorrectedSolver_getSolution():
    G = np.random.rand(3, 3)
    b = np.random.random(3)
    mus = [0.8]
    prob = ContactProblem(G, b, mus)
    solver = RaisimCorrectedSolver()
    solver.setProblem(prob)
    x0 = np.zeros(3)
    settings = ContactSolverSettings()
    settings.max_iter_ = 1000
    settings.th_stop_ = 1e-6
    settings.rel_th_stop_ = 1e-6
    solver.solve(prob, x0, settings)
    lam = solver.getSolution()

def test_RaisimCorrectedSolver_getSolution2():
  npzfile = np.load(test_python_path/'data/sliding_cube.npz')
  G = npzfile["G"]
  g = npzfile["g"]
  mus = npzfile["mus"].tolist()
  lam0 = npzfile["lam0"]
  i =0
  lam0i = lam0[3*i:3*(i+1)]
  Gii = G[3*i:3*(i+1), 3*i:3*(i+1)]
  Gi = G[3*i:3*(i+1),:]
  gi = g[3*i:3*(i+1)]
  ci = Gi@lam0 + gi - Gii @ lam0i
  lam_v0i,_,_,_ = np.linalg.lstsq(Gii,-ci,rcond=None)
  nc = g.shape[0]
  prob = ContactProblem(G,g,mus)
  solver = RaisimCorrectedSolver()
  solver.setProblem(prob)
  settings = ContactSolverSettings()
  settings.max_iter_ = 1000
  settings.th_stop_ = 1e-6
  settings.rel_th_stop_ = 1e-6
  hasConverged = solver.solve(prob, lam0, settings)
  lam = np.expand_dims(solver.getSolution(), -1)
  assert hasConverged
  lam0b = np.zeros((nc,1))
  lam0bi = lam0b[3*i:3*(i+1)]
  cib = Gi@lam0b + gi - Gii @ lam0bi
  lam_v0ib,_,_,_ = np.linalg.lstsq(Gii,-cib, rcond = None)
  settings = ContactSolverSettings()
  settings.max_iter_ = 1000
  settings.th_stop_ = 1e-6
  settings.rel_th_stop_ = 1e-6
  hasConverged = solver.solve(prob, lam0b, settings)
  lamb = np.expand_dims(solver.getSolution(), -1)
  assert hasConverged


if __name__ == '__main__':
    import sys
    import pytest
    # sys.exit(pytest.main(sys.argv))
    # test_pyCCPNewtonPrimalSolver_gradients()
    # test_pyCCPNewtonPrimalSolver_hess()
    # test_pyCCPNewtonPrimalSolver_solve2()
    test_pyCCPNewtonPrimalSolver_solve3()
